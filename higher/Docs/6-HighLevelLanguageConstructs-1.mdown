High Level Language Constructs 1
================================

Contents
--------

1. Introduction
2. The Ruby Programming Environment: IRB
3. The Ruby Programming Environment: Editing
4. The Ruby Programming Environment: Input and Output
5. Data Types
6. Variables and Constants
7. String Variables and Functions
8. Variables and Scope
9. Operators
10. Programming Constructs: Sequence
11. Programming Constructs: Selection
12. The IF statement
13. The If..then..else statement
14. Relational and logical Operators: And, Or, Xor, Not.
15. Nested IF statements
16. If...then..elsif
17. Case statements
18. Summary

1. Introduction
---------------

This topic introduces you to the Ruby programming language and the tools used for building programs using Ruby.

These materials cover the basic programming concepts needed for SQA Higher Computing: variables, operators, loops, conditional statements, comparison operators. We also look at a few standard algorithms.

### Conventions ###

This document uses certain styles to show you what to type in. Code will always be presented in `this font`.  When you have to type something in your Terminal program, it will be presented like this:

>	`$ ls`

You should not type the `$` sign. The `$` is there to indicate the command prompt which may be different on your system.

### Further Reading ###

There are numerous Ruby resources on the web.  One that you might find very useful is Chris Pine's book [Learn to Program](http://pine.fm/LearnToProgram/), which uses Ruby to teach programming and is freely available online.

2. The Ruby Programming Environment: IRB
----------------------------------------

Ruby comes with a program called IRB ("Interactive RuBy"). This is a program which runs in your Terminal and lets you type Ruby commands and immediately see their results.

Try IRB now. Open your Terminal program and type:

>	`$ irb`

You should notice the command prompt changes to:

>	`>>`

and the computer is waiting for you to type something.  Type these lines, pressing return after each line:

>	`>> a = 10`  
>	`>> b = 20` 
>	`>> a + b` 

Your output should look like this:

>	`>> a = 10`  
>	`=> 10`  
>	`>> b = 20`  
>	`=> 20`  
>	`>> a + b`  
>	`=> 30`  
>	`>>`  

What we've just done is created two variables - `a` and `b` - and added them together. IRB printed the result for us at each stage using the `=>` prompt line.

You can use IRB for multi-line commands too, such as loops.  Try this:

>	`>> for i in 1..5 do`  
>	`?> puts i`  
>	`>> end`  
>	`1`  
>	`2`  
>	`3`  
>	`4`  
>	`5`  
>	`=> 1..5`  

Notice IRB recognises that the line `for i in 1..5 do` is not a complete line? You know that because the next command prompt is `?>` instead of `>>`.

To quit IRB, type `quit` at the command prompt.

3. The Ruby Programming Environment: Editing Files
--------------------------------------------------

IRB is useful for quickly testing your ideas about how Ruby works.  If you get stuck at any point in a program, just fire up IRB and try some things out.

When you're working on longer programs, though, you'll want to write the program as a file so that you can change it and re-run it without typing it all in again.  A Ruby program is just a plain text file, whose name ends in .rb.

To create a Ruby program, just open up a text editor (e.g. TextWrangler or TextMate) and start typing your code.

To run your code, save it first and then type:

>	`$ ruby myprogram.rb`  

...in the Terminal.  If you're running in TextMate, you can just hit Command-R to run your program.

4. The Ruby Programming Environment: Input and output
-----------------------------------------------------

In this course, you will mostly be programming Ruby with a text interface.  This means you need some way to display text from your program.  In Ruby this is usually done with the `puts` function.

Try this in IRB:

>	`>> a = "This is some text"`  
>	`>> b = "This is some other text`  
>	`>> puts b`  
>	`>> puts a`  

You should see the following in IRB:

>	`>> a = "This is some text"`  
>	`=> "This is some text"`  
>	`>> b = "This is some other text"`  
>	`=> "This is some other text"`  
>	`>> puts b`  
>	`This is some other text`  
>	`=> nil`  
>	`>> puts a`  
>	`This is some text`  
>	`=> nil`  

So when you told IRB to `puts a`, IRB printed the text that you had stored in the variable `a`.

You can print out the results of mathematical operations too:

>	`>> puts  10 * 100`  

IRB should respond by printing the number 1000.

To get input from the user, you can use the `gets` function:

>	`puts "Please type your name: "`  
>	`user_name = gets`  

Remember that `gets` returns a String object to you. If you want to have the user type in a number, you'll have to ask the String to convert itself into a number.

5. Data Types
-------------

Ruby is an _Object-Oriented_ programming language, although we won't use many object-oriented features.  If a language is _Object-Oriented_, it means that variables have a certain type and can be made to do certain things, depending on their type.

Here is a simple Ruby program which creates a String (text) object, asks it to convert itself to uppercase and prints out the results. Type this in IRB:

>	`lower = "this is my text"`  
>	`upper = lower.upcase`  
>	`puts lower`  
>	`puts upper`  

When you typed `lower.upcase`, what you're really doing is asking the String (text) object called `lower` to create a new String object which has all the same letters, but in UPPERCASE.  Then we printed both strings using `puts` and the result looks like this in IRB:

>	`>> lower = "this is my text"`  
>	`=> "this is my text"`  
>	`>> upper = lower.upcase`  
>	`=> "THIS IS MY TEXT"`  
>	`>> puts lower`  
>	`this is my text`  
>	`=> nil`  
>	`>> puts upper`  
>	`THIS IS MY TEXT`  
>	`=> nil`  

Ruby supports most of the kinds of data that you have seen before:

* Numbers (both Integer and Floating-point)
* String

Ruby handles Boolean variables a bit differently from some other languages. There's no Boolean "type" in Ruby. Instead, Ruby treats Zero (0) as false and all other numbers as true.  You can treat a Number as a boolean variable by setting it to 1 for true and 0 for false.

6. Variables and Constants
--------------------------

In Ruby, there are a few rules for the way you create variable names:

1. **No spaces, ever.** You can use an under_score if you want to.
2. Variables start with a lower-case letter.
3. Constants start with an upper-case letter.

In Ruby, constants are names that you can assign a value to only once.  Here's an IRB example:

>	`>> MY_CONST = 1`  
>	`=> 1`  
>	`>> puts MY_CONST`  
>	`1`  
>	`=> nil`  
>	`>> MY_CONST = 2`  
>	`(irb):19: warning: already initialized constant MY_CONST`  

### Variable Declarations ###

You don't have to declare variables in Ruby. Remember that, in Ruby, everything is a object.  You don't have to tell Ruby which variable names you're going to use before you use them, but you sometimes have to _initialise_ variables before you work with them.  We'll talk more about initialising variables when we talk about Arrays.

Here's a simple Ruby program that adds two numbers together:

>	`a = 6`  
>	`b = 7`  
>	`puts a + b`  

What we're doing there is creating two Number objects with the values 6 and 7, then assigning them to the variables `a` and `b`.

### Example Program: Calculating The Area of a Rectangle ###

In this example, we'll ask the user to type in the length and width of a rectangle and then print out the area.

First, we'll print a message asking the user to enter the length of the rectangle:

>	`puts "Please enter the length of the rectangle:"`  

Thenn, we'll read the number the user types in:

>	`length = gets.to_i`  

Remember that `gets` returns a String and we want the `length` variable to hold a number. We use `to_i` in Ruby to ask a string to convert itself into an Integer. 

Next, we prompt the user for the rectangle's width and store the Integer in a variable called `width`:

>	`puts "Please enter the width of the rectangle:"`  
>	`width = gets.to_i`  

Finally, we'll calculate the size of the area and print it out:

>	`area = length * width`  
>	`puts "The area of the rectangle is #{area}."`  

The `#{}` notation might be a little confusing. When you're printing out a String, you can use `#{}` to have the value of a variable inserted into the string.  In this case we used `#{area}` to put the value of the `area` variable into the output.

Here's the final code:

>	`puts "Please enter the length of the rectangle:"`  
>	`length = gets.to_i`  
>	`puts "Please enter the width of the rectangle:"`  
>	`width = gets.to_i`  
>	`area = length * width`  
>	`puts "The area of the rectangle is #{area}."`  

Type this into your text editor, save the file as `AreaOfARectangle.rb` and run the program.  The result should look like this:

>	`$ ruby AreaOfARectangle.rb `  
>	`Please enter the length of the rectangle:`  
>	`20`  
>	`Please enter the width of the rectangle:`  
>	`100`  
>	`The area of the rectangle is 2000.`  

### Example Program: Calculate the Circumference of a Circle ###

Let's put together everything that we've seen so far: variables, constants, input and output to write a program to calculate the circumference of a circle.

Remember that the formula for the circumference of a circle is:

>	2 X Pi X r

The value of Pi won't change during our program, so we can declare that as a constant. We'll ask the user to enter the radius of the circle, then calculate and display the result.

There is one slight change from the previous program. In this program, we want to let the user enter a floating-point number for the radius.  Remember that `gets` returns a String object containing the text entered by the user? We fixed that in the last program by asking that string to convert to an Integer using:

>	`length = gets.to_i`  

In this program, we need to use `to_f` to convert the String into a floating-point number:

>	`radius = gets.to_f`  

Here's the complete program, with comments in the lines beginning with `#`:

>	`# Define Pi as a constant (by using uppercase letters)`  
>	`PI = 3.14159`  

>	`# Ask the user for the radius of the circle`  
>	`puts "Please enter the radius of the circle:"`  
>	`radius = gets.to_f`  
>	`circumference = 2 * PI * radius`  
>	`puts "The circumference of the circle with radius #{radius} is #{circumference}"`  

Save this program in a file called `CircumferenceOfACircle.rb` and run it:

>	`$ ruby CircumferenceOfACircle.rb `  
>	`Please enter the radius of the circle:`  
>	`10`  
>	`The circumference of the circle with radius 10 is 62.8318`  


7. String Variables and Functions
---------------------------------

String objects in Ruby are very powerful.  There are lots of functions that a String object can perform, and we'll look at some of these in this section.

### Concatenation ###

The word _concatenation_ means _to join_, so 'string concatenation' means joining String objects together.

Firstly, let's create two String objects. Type these into IRB:

>	`>> line_one = "It was a bright cold day in April"`  
>	`>>line_two = "and the clocks were striking thirteen"`  

We're creating these String objects by typing _literal_ strings into the program.  You've already done this with Number objects when you typed code like:

>	`a = 10`  

In the line of code above, `10` is a _literal_ Integer. In our string example `"It was a bright cold day in April"` is a _literal_ string.

In Ruby, we use the `+` symbol to concatenate strings:

>	`finished_line = line_one + line_two`  

If you typed in these three lines exactly, IRB should print:

>	`=> "It was a bright cold day in Apriland the clocks were striking thirteen"`  

What's the problem?  Well, there's no space between "April" and the word "and": "Apriland".  That's because we created `line_one` and `line_two` with no spaces at either end, and the `+` operator doesn't insert a space for us - it just joins the two strings end-to-end.

How can we fix this? Let's concatenate a space in between.  Type this into IRB:

>	`>> finished_line = line_one + " " + line_two`  
>	`=> "It was a bright cold day in April and the clocks were striking thirteen"`  

### Getting the length of a String ###

Because Strings are objects in Ruby we can ask a String to tell us how long it is.  Let's use the same string as in the last example in IRB:

>	`>> line_one = "It was a bright cold day in April"`  
>	`>> puts line_one.length`  

IRB should respond with the number 33.

### Reversing a String ###

A String object can convert itself into a new string with all the letters reversed using the `reverse` function.

Try this in IRB:

>	`>> line_one = "It was a bright cold day in April"`  
>	`>> puts line_one.reverse`  

You should get:

>	`>> puts line_one.reverse`  
>	`lirpA ni yad dloc thgirb a saw tI`  
>	`=> nil`  

### Changing the Case of a String ###

We've already seen the upcase function that a string can perform - it creates a new String object with the same characters in the original String, but in uppercase.

Ruby strings can be made to change case.  Type these lines into IRB:

>	`>> a = "Apple Computer"`  
>	`=> "Apple Computer"`  
>	`>> b = a.upcase`  
>	`=> "APPLE COMPUTER"`  
>	`>> c = b.downcase`  
>	`=> "apple computer"`  

In the first line, we set the variable `a` to contain a String object with the text "Apple Computer", which is a mixture of upper and lower case letters.  Next, we create the variable `b` and assign to it a version of `a` that has been changed into all-UPPERCASE. Finally, we create `c`, which has a version of `b` that has been converted to all lowercase.

### Comparing Strings ###

One of the most important String operations is comparing two strings to see if they are equal.  In Ruby, you can simply use `==` for Strings.  Code such as :

>	`string1 == string2`

will return `true` if `string1` and `string2` are identical in every character, **including case**.  This is a *case-sensitive* comparison.  Try this in IRB:

>	`"Foo" == "Foo"  

IRB should return `true`.  However, if you try this:

>	`"FOO" == "Foo"`  

IRB will return `false` because the case of the O's differ.

We can do a *case-insensitive* comparison between two strings by asking one string whether it is equal to another.  The function for this is `casecmp`.  
Try this in IRB:

>	`"FOO".casecmp("foo")`  

Read that line as "ask the string FOO if it is equal to the string foo". The result should be `0`.

Why zero?

Well, `casecmp` doesn't return a simple true/false value. It returns a number that will be:

* Less than zero if the first string sorts before the second.
* Exactly zero if the strings are the same.
* More than zero if the first string sorts after the second string.

9. Operators
------------

In any programming language, operators are used to make changes to variables - whether to combine them or assign new objects to the variables.

### Assignment ###

Assignment means placing some value in the 'box' of a certain variable. Ruby uses the equals sign ("=") to assign values to variables.

>	`a = 6`  

This code creates a variable `a` and assigns a new Integer object to it with the value 6.

### Equality ###

Since we've already used the `=` sign for assignment, what can we use to test if two numbers are equal?  Ruby uses *two* equals signs, the `==` operator.

### Mathematical Operators ###

Ruby uses the symbols you would expect for maths:

* Addition: +
* Subtraction: -
* Multiplication: *
* Modulus: %

Exponentiation (raising a number to the power of another number) is done using the `**` operator. Some other languages use  the `^` operator. Try this in IRB:

>	`a = 2`  
>	`puts a**2`

IRB should return `4`.

### Operator Precedence ###

When several operators are used in a single expression, the intended order can be ambiguous. Take the following code, for example:

>	`a = 3 * 10 + 5`  

Should the value of `a` be 30 (3x10, then add 5) or 45 (10+5, then multiply by 3)?  Programming languages use a set of rules called *operator precedence* to ensure that these ambiguous statements are consistently interpreted.

Ruby has the following precedence rules, in order from first to last:

1. Exponentiation (`**`)
2. Multiply (`*`), Divide (`/`) and Modulus (`%`)
3. Addition (`+`) and subtraction (`-`)

This means that, in the following example:

>	`a = 2**2 * 10 + 1`  

the answer is 41 because the operators are evaluated in this order:

>	`2**2`  
>	`4 * 10`  
>	`40 + 1`  

When you need to ensure that operators are evaluated in a specific order, use parentheses to group them. Expressions in parentheses are evaluated first, regardless of operator precedence.

Try these two examples in IRB:

>	`1 + 1 * 2`  
>	`(1 + 1) * 2`  

The first example evaluates to 3 because the `1 * 2` operation was done before the `1 +` operation, thus the final addition was `1 + 2`.

The second example evaluates to 4 because `1 + 1` was evaluated first, then mutliplied by 2, to give `2 * 2`.

Try to work out the result of these expressions, then try them in IRB:

>	`4 + 5 * 2`  
>	`(4 + 5) * 2`  
>	`3 + (7 - 5)**2 * 4`  


10. Programming Constructs
--------------------------

### Sequence ###

Sequence is the order in which the computer executes lines of code.  Under normal circumstances, lines of code are executed one after the other, from the top of the program to the bottom.

For example, in the following program:

>	`a = "Hello World"`  
>	`b = "This is my Ruby program"`  
>	`puts a`  
>	`puts b`  

The computer will print the contents of `a`, follwed by the contents of `b`, then the program will terminate.

### Selection ###

Control structures in programming languages let you make decisions about which instruction to perform next.  Going directly from top to bottom of a program isn't always exactly what you want. Sometimes you need to do different instructions depending on the information available to the program.

Ruby has a large number of constructs that allow selection of different instructions, but this section will focus on these:

* The `if` statement.
* Logical operators in decision making.
* The `if .. else` statement.
* Nested `if` statements.
* Multi-way branching with `elsif`.
* The `case` statement.

### The If Statement ###

In English, you might give an instruction like "If it is raining, take an umbrella".  That is a *conditional statement* - only take an umbrella if the condition "it is raining" is true. There's no need to take an umbrella if it's not raining.

In Ruby, the if statement takes the following form:

>	`if <condition> then`  
>	`   <... code ...>`  
>	`end`  

*Fixme: Is this correct?*
In Ruby, anything that can be interpreted as a Number can be used as a `<condition>`.  When used as true/false values, Numbers are interpreted this way:

* If the number is zero, it's false.
* If the number is anything other than zero, it's true - even if it's a negative number.
*/FIXME*

### Example: If Statement ###

Suppose we want to write a program to ask the user for a number. If the number has the same value as one stored in a constant, the program will display a message of congratulations.

Here is the pseudocode algorithm:

1. Ask a number from the user
2. Get the number the user types
3. If (the number typed == the program constant) then
4.   Display "Well done, you guessed correctly!"
5. Display "Sorry, not correct!"

The full Ruby code is shown below:

>	`# Remember: in Ruby, names which start with `  
>	`# 			capital letters are constants.`  
>	`SECRET_NUMBER = 100`  
>  
>	`# 1. Ask the user for a number`  
>	`puts "Please guess a number:"`  
>
>	`# 2. Get the number the user types`  
>	`# (Remember that we need to use .to_i to convert the user's`  
>	`# typing into an Integer.)`  
>	`guessed_number = gets.to_i`  
>	
>	`if guessed_number == SECRET_NUMBER then`  
>	`	puts "Congratulations, you guessed correctly!"`  
>	`end`  
>	
>	`puts "Program end!"`  

### Example: Checking User Input ###

*Problem:* Write a program to accept numbers typed at the keyboard and print them out.  The program terminates when `-1` is entered.

Pseudocode:

1. Input number
2. If number > 0 then
3. Output number
4. end
5. Print message
6. Terminate

### The If...then...else statement ###

So far, we have seen how you can use `if..then` to conditionally execute code. With `if..then`, the choice is simple: either execute the code contained in the `if` statement, or don't execute it.

What if you want to provide two alternative blocks of code to be executed depending on whether a condition is true or false? That's what `if..then..else` is for:

>	`if <condition> then`  
>	`<...code block 1...>`  
>	`else`  
>	`<...code block 2...>`  
>	`end`  

If the `<condition>` is true, `code block 1` will be executed. If `<condition>` is false, `code block 2` will be executed.

### Example: Single or Double ###

**Problem:** Write a program to tell the user whether the number they typed in has one digit or two digits.

**Pseudocode:**

1. As the user to input a number between 1 and 99
2. If the number < 10 then
3.  Print "Single digit"
4. else
5.  Print "Double digit"
6. end

**Ruby:**

>	`# Ask the user`  
>	`puts "Please enter a number between 1 and 99:"`  
>	
>	`# Get the user input, convert it to Integer with to_i`  
>	`user_number = gets.to_i`  
>	
>	`# Compare it to 10`  
>	`if user_number < 10 then`  
>	`	puts "Single digit"`  
>	`else`  
>	`  puts "Double digit"`  
>	`end`  

### Example: Biggest Number ###

**Problem:** What is the output of the following code:

>	`number_one = 10`  
>	`number_two = 5`  
>	
>	`if number_one > number_two then`  
>	`	puts "number_one is biggest"`  
>	`else`  
>	`	puts "number_two is biggest"`  
>	`end`  

**Solution:** This piece of code uses two integer variables, `number_one` and `number_two`. The variable `number_one` is assigned a value of 10, and `number_two` is assigned a value of 5. 
The condition for the `if` statement is "is `number_one` greater than `number_two`"? If this is true then the statement "`number_one` is biggest" is displayed. If the condition is false then the statement "`number_two` is biggest" is displayed on the screen. 

In this case the condition is true since `number_one` has a value of 10, which is greater than the value of 5 that has been assigned to `number_two` and so the output from this code is:

>	`number_one is biggest`  

**Example:** `BiggestNumber.rb`

### Example: Not equal to zero ###

**Problem:** What is the output of the following code:

# Program to test if variables are not equal to zero

>	`value_one = 10`  
>	`value_two = 0`  
>	
>	`if (value_one != 0) and (value_two != 0) then`  
>	`  puts "one"`  
>	`else`  
>	`  puts "two"`  
>	`end`  

**Solution:** This condition for the `if` statement uses a logical `and`. It is testing if `value_one` is not equal to zero and if `value_two` is not equal to zero. In this case `value_two` is equal to zero (true) but `value_one` is not (false). Therefore the whole expression is false, and the text `Two` would be printed on the screen.

**Example:** `NotEqualToZero.rb`

###Exercise: Which is Bigger?###

**Time:** 30 min.

**Problem:** Write a program which prompts a user to type in two numbers - ﬁrst one, then the other. The program responds by printing the bigger of the two. Use the code fragments in the examples above to help you, and make sure that the program has user-friendly prompts for the input and output.

### Exercise: Even or Odd?###

**Time:** 30 min

**Problem:** Write a program to test if a user entered number is even or odd. 
In this program you will have to use the modulus operator (`%`) to calculate the 
remainder when the value stored in the variable `number` is divided by 2. An even number has no remainder if divided by 2. 

###Exercise: Calculating Wages###

**Time:** 20 min 

**Problem:** Write a program to calculate the commission based wages of a computer salesman. His basic wage is &pound;50 per week and he is expected to sell at least 10 computers. If he sells more than 10 computers, he receives an extra &pound;5.50 per computer he sells after the 10th computer. 

14. Relational and logical operators: And, Or, Xor, Not
------------------------------------------------------

There are two kinds of operators in Ruby: *relational* and *logical*.

Relational operators make comparisons between values: whether one is equal to the other, greater, lesser and so on.

### Relational Operators in Ruby###
<table cellpadding=10 border=1>
<tr><th>Symbol</th><th>Example</th><th>Meaning</th></tr>
<tr><td>`==`</td><td>`a == b`</td><td>`a` equal to `b`</td></tr>
<tr><td>`&lt;`</td><td>`a &lt; b`</td><td>`a` less than `b`</td></tr>
<tr><td>`&lt;=`</td><td>`a &lt; b`</td><td>`a` less than or equal to `b`</td></tr>
<tr><td>`&gt;`</td><td>`a &gt; b`</td><td>`a` greater than `b`</td></tr>
<tr><td>`&gt;=`</td><td>`a &gt; b`</td><td>`a` greater than or equal to `b`</td></tr>
<tr><td>`&lt;`</td><td>`a &lt; b`</td><td>`a` less than `b`</td></tr>
<tr><td>`!=`</td><td>`a != b`</td><td>`a` not equal to `b`</td></tr>
</table>

###Example: Using a Relational Operator###

**Problem:** Make a comparison between two variables `n1` and `n2` to find out if `n1` is greater than or equal to `n2`.

**Solution:** Use the relational operator `&gt;=`.  For example:

>	`n1 &gt;= n2`

###Example: Using a relational operator in an if statement###

**Problem:** Construct an `if` statement that will display a message to the screen if two variables `n1` and `n2` are equal.

**Solution:** The following solution is typical:

>	`n1 = 9`  
>	`n2 = 9`  
>  
>	`if n1 == n2 then`  
>	`puts "n1 and n2 are equal"`  
>	`end`  

###Logical Operators in Ruby###

Logical operators evaluate whether a statement is true or false.

###Logical AND###

An expression that contains a logical `AND` can only be true if *both* parts of the expression are true.

The behaviour of `AND` is often shown as a _truth table_:

>	<table cellpadding=10 border=1>
>	<tr><th>`X`</th><th>`Y`</th><th>`X AND Y`</th><tr>
>	<tr><td>false</td><td>false</td><td>false</td></tr>
>	<tr><td>true</td><td>false</td><td>false</td></tr>
>	<tr><td>false</td><td>true</td><td>false</td></tr>
>	<tr><td>true</td><td>true</td><td>true</td></tr>
>	</table>

Logical `AND` can be used in `if` statents as follows:

>	`if (n1 == 0) and (n2 == 0) then`  
>	`puts "Both n1 and n2 are zero."`  
>	`end`  

This code will only print the statement if `n1` is zero _and_ `n2` is zero.

###AND Example: Password Verification###

**Problem:** A program is written which asks the user to enter a password and to conﬁrm it by entering it again. If both words are equal to a program constant then the program will display a suitable comment. If not, or only one instance of the password is entered the user will be informed. 

**Pseudocode Solution:**

1. Request first password
2. Request second password
3. If (the first password = constant) and (the second password = constant) then
4.   Display the word entered.
5. else
6.   Display the two words and a message stating that they are different.

**Ruby Solution:**

>	`# Define constant (starts with uppercase letter)`  
>	`Password = "Daffodil"`  
>	
>	`# Request first password`  
>	`puts "Password, please:"`  
>	`# Note: no need to use to_i, since we want the password as a string.`  
>	`# However, we do have to use chomp to remove the new line character `  
>	`# at the end that is generated by the user typing return.`  
>	`first_password = gets.chomp`  
>	
>	`puts "Password again, please:"`  
>	`second_password = gets.chomp`  
>	
>	`if (first_password == Password) and (second_password == Password) then`  
>	`  puts "Both words #{Password} are identical."`  
>	`else`  
>	`  puts "The words #{first_password} and #{second_password} are not identical."`  
>	`end`  

###Exercise: Validating Numeric Input and Program Testing###

**Time:** 20 min 

**Problem:** Use this fragments of code you have just seen in this section to help you write a program which will accept a value from the keyboard and print ‘yes’ if it is positive and even. Test your program with positive and negative numbers, odd and even numbers and make sure it passes all the tests. Make a tabulated list of the numbers you use and the results the program gives for each input. Use both positive and negative numbers, not neglecting zero. 

**Solution:** ValidatingNumericInput.rb

###Logical OR###

An expression that contains a logical `OR` is true if *either* part of the expression is true.  This is also known as _inclusive_ `OR`, because either one term, the other term _or both terms_ can be true to make the overall expression true.

The behaviour of `OR` can be expressed in the following _truth table_:

>	<table cellpadding=10 border=1>
>	<tr><th>`X`</th><th>`Y`</th><th>`X OR Y`</th><tr>
>	<tr><td>false</td><td>false</td><td>false</td></tr>
>	<tr><td>true</td><td>false</td><td>true</td></tr>
>	<tr><td>false</td><td>true</td><td>true</td></tr>
>	<tr><td>true</td><td>true</td><td>true</td></tr>
>	</table>

Here's an example of using `OR` in Ruby code:

>	`number = 9`  
>	`if (number < 0) or (number > 5) then`  
>	`puts "The number is not in the range 0-4."`  
>	`end`  

In this program fragment, when `number` is either less than zero _or_ more than 5, the message will be shown.

###OR Example: Wash the Car?###

**Problem:** A program is written to prompt the user to enter two conditions - a temperature and a weather forecast. If either or both of the conditions are met then the program will display a suitable message to go and wash the car. If no conditions are met the user will be informed that washing the car is not a good idea. The conditions are compared to program constants. 

**Pseudocode Solution:** 

1. Request a temperature from the user
2. Request weather condition
3. If (temperateure >= 15) or (condition = "Sunny") then
4.   display "Wash the car"
5. else
6.   display "Not a good idea!"

**Ruby Solution:** WashTheCar.rb

###Logical Exclusive OR (XOR)###

`XOR` is a slightly different form of `OR` that evaluates to `false` if neither condition is true, or if _both_ conditions are true.  Here is the truth table:

>	<table cellpadding=10 border=1>
>	<tr><th>`X`</th><th>`Y`</th><th>`X XOR Y`</th><tr>
>	<tr><td>false</td><td>false</td><td>false</td></tr>
>	<tr><td>true</td><td>false</td><td>true</td></tr>
>	<tr><td>false</td><td>true</td><td>true</td></tr>
>	<tr><td>true</td><td>true</td><td>false</td></tr>
>	</table>

You can read XOR as "one or the other but not both".  XOR is not particularly common in programming.

###Logical NOT###

NOT simply inverts the truth of any true/false value.  It has a simpler truth table:

>	<table cellpadding=10 border=1>
>	<tr><th>`X`</th><th>`NOT X`</th><tr>
>	<tr><td>false</td><td>true</td></tr>
>	<tr><td>true</td><td>false</td></tr>
>	</table>

NOT is very useful in programming.  For example:

>	`if (number_one == 6) and not (number_two == 6) then`  
>	` puts "Foo"`  
>	`end`

This code will only execute the `puts` line if `number_one` has the value 6 _and_ `number_two` does _not_ have the value 6.

15. Nested IF Statements
------------------------

If a condition has to be tested that depends on whether another condition is already `true` (such as "If it’s 6:30 p.m. and if I’m logged on" then.....), nested `If` statements can be used.  A nested If statement is one that’s enclosed within another If statement.

The format for a nested If statement is as follows: 

>	`if <condition> then`  
>	`if <another condition> then`  
>	`<statements>`
>	`else`  
>	`<other statements>`  
>	`end`  
>	`end`  

`If`statements can be nested, but care should always be taken to ensure that the `else` statement is associated with the correct `if`.

The following examples show the nested if statement.

###Testing for range and number of digits###

Read the following Ruby code:

>	`#`  
>	`# Testing for range:`  
>	`# This program will prompt the user for a number between 1 and 99.`  
>	`# The program will test the number to see if it is less than 10 and inform`  
>	`# the user that it's a single-digit number.`  
>	`#`  
>	`# If it is >9, it will output "double-digit number", otherwise "out of range".`  
>	``  
>	`puts "Please enter a number between 1 and 99"`  
>	`number = gets.to_i`  
>	``  
>	`if(number >= 0) and (number <= 99) then`  
>	`  if (number < 10) then`  
>	`    puts "#{number} is a single-digit number"`  
>	`  else # Matches "if (number < 10)"`  
>	`    puts "#{number} is a double-digit number"`  
>	`  end`  
>	`else # Matches "if(number >= 0) and (number <= 99)"`  
>	`  puts "Out of range"`  
>	`end`  

**Solution:** The user is prompted to enter a number between 1 and 99 and the value entered is stored in the variable `number`. If the value is not within the specifed range (greater than 0 and less than 100), then the `else` part of the outer `if` statement is executed and the message _Number is out of range_ is displayed on the screen and the program is finished.

On the other hand, if the value is within range, then the first part of the outer `if` statement is executed which contains several lines of code between `if` and `end`. Within this block of code is another `if` statement which tests if the number is less than 10, in which case the message single digit number is displayed on the screen, otherwise (`else`), the message double digit number is displayed on the screen.

16. If..then..elsif
-------------------

Nested `if` statements can give rise to what is known as 'spaghetti code' - code that is hard to follow and understand.  The `elsif` ("else if") statement can simplify this.

The structure of the statement is as follows:

>	`if <condition> then`  
>	`<statements>`  
>	`elsif <condition2> then`  
>	`<statements2>`  
>	`elsif <condition3> then`  
>	`<statements3>`  
>	`else`  
>	`<statements4>`  
>	`end`  

The conditions are evaluated in the order in which they appear in the program.  If any condition is true, the code block that appears after it is executed and the program jumps to the `end` statement.  There is no limit to the number of `elsif` clauses.

Consider the situation where you have two boolean variables, `val1` and `val2`, and you need to take actions for each of the possible combinations of true and false. 

Using nested `if` statements, you would have to write:

<pre>
if val1 == true then
  if val2 == true then
    [statements for true/true]
  else
	[statements for true/false]
  end
else
  if val2 == false then
  	[statements for false/true]
  else
  	[statements for false/false]
  end
end
</pre>

Using `elsif` will produce more compact code that is easier to read and follow:

<pre>
if val1 and val2 then
  [statements for true/true]
elsif val1 and not val2 then
  [statements for true/false]
elsif not val1 and val2 then
  [statements for false/true]
else
  [statements for false/false]
end
</pre>

###Example: Using elsif to calculate the number of digits in a number###

**Problem:** How can an `elsif` statement be used to ﬁnd out whether an integer number is within a certain range (a positive number) and how many digits it contains? 

**Solution:** 
<blockquote>
<pre>
puts "Please enter a number between 1 and 9999:"
number = gets.to_i

if number >= 1000 then
  puts "Four digits"
elsif number >= 100 then
  puts "Three digits"
elsif number >= 10 then
  puts "Two digits"
elsif number >= 0 then
  puts "One digit"
else
  puts "Out of range"
end
</pre>
</blockquote>

* You start testing if the variable `number` is greater than or equal to 1000, in which case there are 4 digits (you must be assuming that the variable `number` is not greater than 9999) and the program prints "Four Digits". If it is not greater than or equal to 1000, then you move onto the next branch of the `if` statement. 
* The next condition tests the variable `number` to see if it is greater than or equal to 100. If this is true then you know the variable `number` has a value between 100 and 999, and so it must have 3 digits, and the program prints "Three digits". Again, if this condition is not fulﬁlled, then you move onto the next branch of the `if` statement. 
* The next condition tests the variable `number` to see if it is greater than or equal to 10. If this is true then you know the variable `number` has a value between 10 and 99, and so it must have 2 digits, and the program prints "Two digits". Again, if this condition is not fulﬁlled, then you move onto the next branch of the `if` statement.
* The next condition tests the variable `number` to see if it greater than or equal to 0. If this is true then you know that the variable number has a value between 0 and 9, and so it must have one digit. The program prints "One Digit". 
* The next branch of the `if` statement is not an `elsif` branch, but an `else` branch, and so does not have a condition but is the branch that is executed if none of the other conditions are met. Execution of this branch of the `if` statement results in the message "Out of Range" being displayed on the screen. 

###Example: Grades and Marks###

**Problem:** Write a program using the `elsif` construct for a user to input a test result and output the corresponding grade. Test scores range from 0 to 100 and the grades from "A" being the highest to "E" the lowest.